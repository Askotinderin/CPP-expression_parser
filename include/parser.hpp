#pragma once


#include "lexer.hpp"



const std::array<std::array<char, OP_SIZE>, OP_SIZE> operator_precedence = {{
//      EOE,    id      +       *       -       /       %       (       )       ^       &       |// row is token in expression (right)
    {   'a',    '<',    '<',    '<',    '<',    '<',    '<',    '<',    'x',    '<',    '<',    '<' },  // EOE
    {   '>',    'x',    '>',    '>',    '>',    '>',    '>',    'x',    '>',    '>',    '>',    '>' },  // id
    {   '>',    '<',    '>',    '<',    '>',    '<',    '<',    '<',    '>',    '<',    '>',    '>' },  // +
    {   '>',    '<',    '>',    '>',    '>',    '>',    '>',    '<',    '>',    '<',    '>',    '>' },  // *
    {   '>',    '<',    '>',    '<',    '>',    '<',    '<',    '<',    '>',    '<',    '>',    '>' },  // -
    {   '>',    '<',    '>',    '>',    '>',    '>',    '>',    '<',    '>',    '<',    '>',    '>' },  // /
    {   '>',    '<',    '>',    '>',    '>',    '>',    '>',    '<',    '>',    '<',    '>',    '>' },  // %
    {   'x',    '<',    '<',    '<',    '<',    '<',    '<',    '<',    '=',    '<',    '<',    '<' },  // (
    {   '>',    'x',    '>',    '>',    '>',    '>',    '>',    'x',    '>',    '>',    '>',    '>' },  // )
    {   '>',    '<',    '>',    '>',    '>',    '>',    '>',    '<',    '>',    '<',    '>',    '>' },  // ^
    {   '>',    '<',    '<',    '<',    '<',    '<',    '<',    '<',    '>',    '<',    '>',    '<' },  // &
    {   '>',    '<',    '<',    '<',    '<',    '<',    '<',    '<',    '>',    '<',    '<',    '>' },  // |
}};                                                                             // collumn is token in stack (left)


class Parser {
private:
    std::stack<Token> t_stack;
    std::stack<float> f_stack;


public:
    Parser ();
    void operator() (std::queue<Token>& tokens);
};